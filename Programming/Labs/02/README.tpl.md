(( titul == 2 ))

## Постановка задачи

1. Разработайте и зарегистрируйте навык для Алисы на сервисе Яндекс.Диалоги;

2. В качестве backend-a для навыка реализуйте приложение на языке С++ выполняющее следующие функции:
   1. Составление продуктовой корзины:
      * Добавление продукта в корзину;
      * Удаление продукта из корзины;
      * Очистка корзины;
      * Вывод списка товаров в корзине;
      * Подсчёт стоимости товаров в корзине.
   2. Вывод справочной информации по навыку;
   3. Регистрацию webhook-ов сторонних сервисов;
   4. Отправку данных на сторонние сервисы. 

3. В качестве стороннего сервиса реализуйте приложение на языке Python выполняющее следующие функции:
   1. Ожидание данных о покупке;
   2. Сохранение поступивших данных в excel-документ.

## Цель работы
Целью работы является научится создавать навык для Алисы на сервисе Яндекс.Диалоги и сохранять данные в файлах Excel.

(( folders ))

### Информация о проекте

Стандарт С++: `С++20`
<br>
Компилятор: `g++-10` (gcc v10.2.0)
<br>
ОС: `Ubuntu 20.04.01 LTS`

## Выполнение работы

Разработка проекта началась с регистрации навыка для Алисы. Название навыка выбрано `feora cart`, поскольку у меня были наработки для этого имени и был логотип.

((
image =
   src: "feora-logo.png",
   title: "Логотип для навыка"
))

Следующим этапом стала адаптация проекта лабораторной работы №1 под нужды этой работы. Важным аспектом явилась настойка компиляции и линковки исходного кода, что позволило значительно сократить время компиляции, тем самым ускорив процесс разработки.

На ранних этапах проект уже обладал функциями по работе с файловой системой и обработкой роутинга. был произведен рефакторинг с применением парадигмы ООП, что позволило повысить читабельность кода несмотря на синтаксические особенности языка С++.

Были установлены два слушателя пост запросов на роуты:
1. "/"
2. "/webhooks"

Логика этих слушателей находится в папке ((include=="routes")).

### Роут webhooks

Далее была запрограммирована логика обработки `/webhooks`. Она была вынесена в отдельный класс ((include=="HooksPage")). Этот класс имеет методы настройки хуков и генерации html кода страницы. При инициализации он получает шаблоны html кода из папки [html](./C++/html).
(( c++include = folder:".", module:"HooksPage" ))

Код роута ((include=="rotes/webhooks")) использует этот класс и представляет следующую реализацию:
(( c++include = folder:"rotes", module:"webhooks" ))

Логика отвечающая за изменение файла [json/config.json](./C++/json/config.json) также содержится в классе ((include=="HooksPage")), поэтому об этом думать не приходится.

(( image = src:"webhooks.png", title:"Страница регистрации вебхуков" ))

### Роут root

Основная часть программной логики содержится в роуте ((include=="rotes/root")). Этот роут отвечает за общение с сервисом Yandex.Dialogs. Главной функцией в этом файле является dialog. Она отвечает за генерацию ответа в формате JSON на основе файлов из папки [json](./C++/json).

Остальная часть является большой if-elseif-else конструкцией, которая определяет, когда и какой диалог генерировать.

Также этот роут отвечает за отправление чека пользователя при окончании сессии.

(( c++include = folder:"rotes", module:"root" ))

### File API

Ранее упоминалось взаимодействие с файловой системой, точнее чтение и запись в файлы. Программа работает с JSON файлами из папки [json/dialogs](./C++/json/dialogs), а также с файлом [config.json](./C++/json/config.json). Все эти взаимодействия осуществляются с помощью разработанного класса (( include == "File" )). Этот класс обладает рядом статических и нестатических методов, позволяющих читать и записывать как обычный текст, так и сразу JSON.

(( c++include = folder:".", module:"File" ))

### main.cpp

Входной точкой в код серверной стороны является файл [main.cpp](./C++/main.cpp), который подключает в себя все модули и запускает сервер. Также, он настраивает обработку запросов на сервер рассмотренными выше роутами.

```c++
(( file == "./C++/main.cpp" ))
```

### Работа диалога

Ниже представлены скриншоты работы диалога. Основная логика, отвечающая за выбор диалога, находится в роуте ((include=="rotes/root")).

(( toggle{ == "Функционал \"Корзина\"" ))

(( image = src:"cart1.jpg", title:"Вход в корзину" ))
(( image = src:"cart2.jpg", title:"Добавление в корзину" ))
(( image = src:"cart3.jpg", title:"Что в корзине" ))
(( image = src:"cart4.jpg", title:"Удаление товара, начальное состояние корзины" ))
(( image = src:"cart5.jpg", title:"Удаление товара, команда" ))
(( image = src:"cart6.jpg", title:"Удаление товара, конечное состояние корзины" ))
(( image = src:"cart7.jpg", title:"Очищение корзины" ))
(( image = src:"cart8.jpg", title:"Завершение покупки" ))

После завершение сессии этот роут отправляет изменения post-запросом на питоновский сервер, который сохраняет чек в [excel файл](./Python/data.xlsx).

((toggle}))

((toggle{ == "Функционал \"Помощь\""))

Помощь принимает все команды. Если была запрос `назад`, то происходит выход в главное меню. В любом другом случае осуществляется поиск по файлу диалога [help/all.json](./C++/json/dialog/help/all.json). В настоящий момент имеется справка только для самой корзины, но при желании справку можно дописать в JSON файлах.

(( image = src:"help1.jpg", title:"Режим справки" ))
(( image = src:"help2.png", title:"Справка по корзине" ))

((toggle}))

### Питоновский клиент

[Клиент на питоне](./Python/main.py) обрабатывает поступающие пост запросы. Он содержит переменную буфер. Когда её размер превосходит предустановленную константу `BUFFER_SIZE`, происходит сохранение чеков в файл [data.xlsx](./Python/data.xlsx).

(( toggle{ == "Исходный код" ))

```python
(( file == "./Python/main.py" ))
```

(( toggle} ))

## Вывод
Все поставленные задачи выполнены, а цель работы достигнута - разработано распределённое клиент-серверное приложение, использующее возможности Yandex.Dialogs для обработки запросов пользователя. Благодаря этому реализовано приложение, выполняющее составление списка продуктов и подсчет суммарной стоимости чека.

В разработке С++-сервера использованы две сторонние библиотеки: `json` и `cpp-httplib`. Python-клиент использует библиотеку `flask` обработки post-запросов.

Практика показывает, что любое приложение рано или поздно требует хранения информации на серверах, поэтому умение разрабатывать клиент-серверные приложения является важным навыком в современном мире программирования. Также, повышается популярность использования голосовых помощников и умение разрабатывать такие приложения является важным навыком.

(( folders ))